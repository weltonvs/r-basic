---
title: "Estructura de datos en R"
author: "Welton Vieira dos Santos"
date: "9/2/2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Vectores
Un vector es una secuencia ordenada de datos. `R` dispone de muchos tipos de datos, por ejemplo:

* **logical:** Lógicos (TRUE o FALSE)

* **integer:** Números enteros, $\mathbb Z$

* **numeric:** Números reales, $\mathbb R$

* **complex:** Números complejos, $\mathbb C$

* **character:** Strings o palabras.

En los vectores de `R`, todos sus objetos han de ser del mismo tipo, es decir, todos números, todos palabras, etc... 

Cuando queramos usar vectores formados por objetos de diferentes tipos, tendremos que usar **listas generalizadas**, **_lists_** que se verá más adelante.

## Básico

* **c():** Utilizado para definir un vector.
  ```{r}
  c(1,2,3)
  ```


* **scan():** Utilizado para definir un vector a través de un scaneo de una variable, archivo, enlaces de internet o manualmente. Se va insertando datos y con double intro sale de interfaz de insección del scan.
  ```{r, eval=FALSE}
  scan()

  ```


* **fix():** Utizado para modificar visualmente el vector $x$.



* **rep(a, n):** Utilizado para definir un vector constante que contiene el dato **_a_** repetido **_n_** veces.
  ```{r}
    rep("Mates",7)
    rep(c(1:10),3)
  ```

## Progresiones aritméticas y secuencias

Una progresión aritmética es una secuencia de números tales que la **diferencia**, _d_, de cualquier par de términos sucesivos de la secuencia es constante.
$$a_n=a_1+(n-1)\cdot d$$

* **sec(a, b, by=d):** Para generar una [progresión aritmética](https://es.wikipedia.org/wiki/Progresi%C3%B3n_aritm%C3%A9tica) de diferencia $d$ que empieza en $a$ hasta llegar a $b$.
  ```{r comment = NA}
  x <- seq(5, 60, by = 5)
  x
  x <- seq(5, 60, by = 3.5)
  x
  x <- seq(60, 5, by = -5)
  x
  
  ```
* **seq(a, b, length.out = n):** Define progresión geométrica aritmética de longitud $n$ que va de $a$ a $b$ con diferencia $d$. Por tanto $d = (b - a)/(n - 1)$
  ```{r comment = NA}
  x <- seq(1, 15, length.out = 5)
  x
  x <- seq(1, 150, length.out = 3)
  x
  ```
* **seq(a, by = d, length.out = n):** Define progresión geométrica aritmética de longitud $n$ y diferencia $d$ que empieza en $a$.
  ```{r comment = NA}
  x <- seq(4, length.out = 7, by = 3)
  x
  x <- seq(50, length.out = 3, by = 50)
  x
  ```
* **1:20**: Define una secuencia de números enteros ($\mathbb Z$) consecutivos entre números $a$ y $b$.
  ```{r comment = NA}
  # Vector de 1 a 5
  1:5
  # Vector de -2 a 5
  -2:5
  # Vector de -2 a 5
  -(2:5)
  # Vector de 30 a -2
  30:-2
  ```
 
## Concatenar vectores

Para unir dos vectores con `R` es muy facil.

```{r comment = NA}
  # Creando un vector de 1 a 7
  vector1 <- seq(1,7)
  vector1
  # Creando un vector de 1 a 10, pero dando saltos de 2 en 2.
  vector2 <- seq(1,10, by = 2)
  vector2
  # Concatenando en un sólo vector los dos vectores anterioes.
  vectortotal <- c(vector1, vector2)
  vectortotal
  # Concatenar un vector de pi con un vector de de 5 a 10 y tambien con el número -7
  c(rep(pi, 5), 5:10, -7)

```

# Funciones

Cuando queremos aplicar una función a cada uno de los elementos de un vector de datos, la función **samply** nos ahorra tener que programar con bucles en `R`:

* **samply(nombre_de_vector, FUN = nombre_de_funcion)):** Para aplicar dicha función a todos los elementos del vector.
  ```{r comment = NA}
    x <- c(1:10)
    # Aplicando el resultado de una función de callback a cada uno de los elementos 
    # del vector x.
    sapply(x, FUN = function(elemento){
      sqrt(elemento)
    })
    
  ```
* **sqrt(x):** Para calcular un nuevo vector con las raíces cuadradas de cada uno de los elementos del vector $x$.
  ```{r comment = NA}
  # Para aplicar la raiz en cada uno de los elementos del vector es muy facil con R
  vector <- c(1:10)
  vector
  sqrt(vector)
    
  ```
  
Dado un vector de datos $x$ podemos calcular muchas medidas estadísticas acerca del mismo:

* **length(x):** Calcula la longitud del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # calculando la longitud o el número de elementos del vector.
  length(vector)
    
  ```
* **max(x):** Calcula el máximo valor del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el mayor valor almacenado en el vector.
  max(vector)
    
  ```
* **min(x):** Calcula el menor valor del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el valor del menor elemento del vector.
  min(vector)
    
  ```
* **sum(x):** Calcula el sumatorio $\left(\sum_{i=1}^{n}x_i\right)$ de todos los elementos del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando la sumatorio del vector.
  sum(vector)
    
  ```
* **prod(x):** Calcula el producto $\left(\prod_{i=1}^{n}x_i\right)$ de todos los elementos del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el producto de todos los elementos del vector.
  prod(vector)
    
  ```
* **mean(x):** Calcula la media aritmética $\left(\frac{1}{n}\cdot \sum_{i=1}^{n}x_i\right)$ de los elementos del vector $x$.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando la media aritmética de los elementos del vector.
  mean(vector)
    
  ```
* **diff(x):** Calcula el vector formado por las diferencias sucesivas entre entradas del vector original $x$, es decir, la diferencia que existe entre un elemento y otro del vector.
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el diferencial entre los elementos del vector.
  diff(vector)
  # Calculando las diferencias de las sumas acumuladas
  diff(cumsum(vector))
  # Calculando las diferencias de los productos acumulados
  diff(cumprod(vector))
    
  ```
* **cumsum(x):** Calcula el vector formado por las sumas acumuladas de las entradas del vector original $x$.
  
  * Permite definir sucesiones descritas mediante sumatorios.
  
  * Cada entrada de **cumsum(x)** es la suma de las entradas de $x$ hasta su posición.
  
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el sumatorio acumulado de todos los elementos del vector.
  cumsum(vector)
    
  ```
* **cummin(x):** Calcula el vector formado por los mínimos valores de las entradas del vector original $x$, es decir, va almacenando los valores que van encontrando desde que ese valor no sea mayor que el siguiente
  
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el mínimo acumulado de todos los elementos del vector.
  cummin(vector)
    
  ```
* **cummax(x):** Calcula el vector formado por los máximos valores de las entradas del vector original $x$, es decir, va almacenando los valores que van encontrando desde que ese valor no sea menor que el siguiente
  
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el máximo acumulado de todos los elementos del vector.
  cummax(vector)
    
  ```
* **cumprod(x):** Calcula el vector formado por los productos acumulados de las entradas del vector original $x$.
  
  ```{r comment = NA}
  
  vector <- c(1:10)
  vector
  # Calculando el producto acumulado de todos los elementos del vector.
  cumprod(vector)
    
  ```
  
# Orden

* **sort(x):** Ordena el vector en orden natural de los objetos que lo forman: el orden númerico cresciente, orden alfabético, etc...
  ```{r comment = NA}
    v = c(1,7,5,2,4,6,3)
    # ordenando los elementos del vector en orden natural.
    sort(v)
    # Ordenando los elementos del vector en orden decresciente.
    sort(v, decreasing = TRUE)
  ```

* **rev(x):** Inverte el orden de los elementos del vector $x$.
  ```{r comment = NA}
    v = c(1,7,5,2,4,6,3)
    # Inviertiendo los elementos del vector.
    rev(v)
  ```
  
  
# Factor
**Factor:** Es como un vector, pero con una estructura interna más rica que permite usarlo para clasificar observaciones.

* **levels**: Atributo del factor. Cada elemento del factor es igual a un nivel. Los niveles clasifican las entradas del factor. Se ordenan por orden alfabético.

* Para definir un factor, primero hay que definir un vector y despues transformarlo por medio de una de las funciones **factor()** o **as.factor()**.
```{r comment=NA}
#Crear un vector de nombres
nombres = c("Juan", "Antonio", "Ricardo", "Juan", "Juan", "Maria", "Maria")
nombres
```
```{r comment=NA}
#Convertir el array anterior en un factor
nombres.factor = factor(nombres) #Convertir a factor el array nombres.
nombres.factor#Consultar el contenido del factor nombres
```
Se observa que tiene un formato peculiar, es decir, las doble comillas desaparecen y además aparece un termino nuevo indicando los niveles donde es presente todos los nombres de contenido, pero sin repetición.

Muy utilizado para clasificar los datos de un vector.
**Ejemplo:**
```{r comment=NA}
genero = c("M","H","H","M","M","M","M","H","H")
genero.fact = factor(genero)
genero.fact
```
Se puede crear tambien utilizando **as.factor()**
```{r comment=NA}
genero.fact2 = as.factor(genero)
genero.fact2
```

Pueden parecer iguales visualmente, pero internamente no lo es.

## La función factor()
* **factor(vector, levels = ...)**: define un factor a partir del vector y dispone de algunos parámetros que permiten modificar el factor que se crea:
  * **levels**: permite especificar los niveles e incluso añadir niveles que no aparece en el vector.
  
```{r comment=NA}
  genero.fact3 = factor(genero, levels = c("M","H","B"))
  genero.fact3

```
  
  
  * **labels**: permite cambiar los nombres de los niveles
```{r comment=NA}
  genero.fact4 = factor(genero, levels = c("M","H","B"), labels = c("Mujer","Hombre",
  "Hermafrodita"))
  genero.fact4

```
  
* **levels(factor)**: permite obtener los niveles del factor
```{r comment=NA}
levels(genero.fact4)
```
Para modificar los niveles del factor
```{r comment=NA}
levels(genero.fact4) = c("Feminino", "Masculino", "Híbrido")
genero.fact4
```

### Factor Ordenado
Hasta ahora he hablado del factor simple, pero hay otros factores conocidos como factor ordenado.

Que es un factor donde los niveles siguen un orden.

* **ordered(vector, levels = ...)**: función que define un factor ordenado y tiene los mismos parámetros que el factor simple.


# Listas
En `R` son conocidas como **list** que es una lista formada por diferentes objetos, no necesariamiente del mismo tipo, cada cual con un nombre interno.

* **list(...)***: función que crea una lista.

  * Para obtener una componente concreta usamos la instrucción **list$componente**.
  
  * También podemos indicar el objeto por su posición usando dobles corchetes: _list[[i]]_. Lo que obtendremos es una lista formada por esa única componente, no el objeto que forma la componente.
  
  **Ejmeplos de creacción de listas:**
  
```{r comment=NA}
x = c(1,5,-2,6,-7,8,-3,-9)
x
```
  
Crear una lista
```{r comment=NA}
L = list(nombre = "temperaturas", datos = x, media = mean(x), sumas = cumsum(x))
L

```

Para acceder a un componente de la lista
```{r comment=NA}
L$media

```

```{r comment=NA}
L$nombre
```
#### Obtener información de una lista
* **str(lista)**: para conocer la estructura interna de una lista
```{r comment=NA}
str(L)
```


* **names(lista)**: para saber los nombres de la lista
```{r comment=NA}
names(L)
```

